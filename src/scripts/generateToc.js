const fs = require('fs');
const md = require('md-directory');

const files = md.parseDirSync('./src/docs', {
  dirnames: true,
});
const sort = (a, b) => {
  const first = a.data.order;
  const second = b.data.order;

  if (typeof first !== 'number') {
    return 1;
  }

  if (typeof second !== 'number') {
    return -1;
  }

  return first - second;
};

function sortByOrder(children) {
  if (children && children.length) {
    children.map(child => sortByOrder(child.children));
  }

  children.sort(sort);
}

// Traverse the nodes in order, setting `up`, `next`, and
// `prev` links.
let prevNode = null;

/* eslint-disable no-param-reassign */
function addNav(node, parentNode) {
  if (parentNode && parentNode.path) {
    node.up = {
      path: parentNode.path,
      title: parentNode.data && parentNode.data.title,
    };
  }

  if (prevNode && prevNode.path) {
    node.prev = {
      path: prevNode.path,
      title: prevNode.data && prevNode.data.title,
    };

    prevNode.next = {
      path: node.path,
      title: node.data && node.data.title,
    };
  }

  prevNode = node;
  parentNode = node;

  node.children.forEach(child => addNav(child, parentNode));
}
/* eslint-enable no-param-reassign */

const makeToc = rootPath => {
  const nodes = { children: [] };

  Object.keys(files)
    .filter(path => path.startsWith(rootPath))
    .map(path => ({ path, data: files[path].data }))
    .forEach(item => {
      let ptr = nodes;
      const path = [];

      item.path
        .replace(rootPath, '')
        .split('/')
        .forEach(name => {
          path.push(name);

          let child = ptr.children.find(child => child.name === name);

          if (!child) {
            child = {
              name,
              children: [],
              data: Object.assign(item.data, {
                order: name === 'index' ? 0 : item.data.order,
              }),
              path: `${rootPath}${path.join('/')}`,
            };

            if (name === 'index') {
              ptr.data = child.data;
            } else {
              ptr.children.push(child);
            }
          }

          ptr = child;
        });
    });

  sortByOrder(nodes.children);
  addNav(nodes, null);

  return nodes;
};

const manual = makeToc('manual/');
const reference = makeToc('reference/');
const tutorial = makeToc('tutorial/');
const rest = ['index', 'resources'].map(fileName =>
  Object.assign(files[fileName], {
    name: fileName,
    path: fileName,
    children: [],
    content: undefined,
    data: Object.assign(files[fileName].data, {
      order: files[fileName].data.order || 0,
    }),
  })
);
const toc = {
  gettingStarted: rest[0],
  manual,
  reference,
  tutorial,
  resources: rest[1],
};

fs.writeFile(
  './src/autogenerated/docsTableOfContents.json',
  `${JSON.stringify(toc)}\n`,
  err => {
    if (err) {
      // eslint-disable-next-line no-console
      console.error('Error writing docsTableOfContents file', err);
    } else {
      // eslint-disable-next-line no-console
      console.log('Documentation table of contents successfully extracted!');
    }
  }
);
